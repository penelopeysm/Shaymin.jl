on:
  push:
    branches:
      - "*"

jobs:
  test:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - uses: julia-actions/setup-julia@v2
        with:
          version: '1'

      - name: DynamicPPL@0.31.0 (old syntax)
        shell: julia --color=yes --project=. {0}
        run: |
          using Pkg
          Pkg.add(name="DynamicPPL", version="0.31.0")
          Pkg.add("Chairmarks")
          Pkg.add("Distributions")
          Pkg.add("AbstractMCMC")

          using DynamicPPL
          using Chairmarks
          using Distributions
          using AbstractMCMC

          @model function _prior_dot_assume1(::Type{TV}=Vector{Float64}) where {TV}
              s = TV(undef, 2)
              s .~ InverseGamma(2, 3)
              m = TV(undef, 2)
              m .~ Normal.(0, sqrt.(s))
              return s, m
          end

          @model function demo_assume_submodel_observe_index_literal1()
              # Submodel prior
              @submodel s, m = _prior_dot_assume1()
              1.5 ~ Normal(m[1], sqrt(s[1]))
              2.0 ~ Normal(m[2], sqrt(s[2]))

              return (; s=s, m=m, x=[1.5, 2.0], logp=getlogp(__varinfo__))
          end

          t = @be sample(demo_assume_submodel_observe_index_literal1(), SampleFromUniform(), 100; progress=false)
          show(Base.stdout, MIME"text/plain"(), t)

      - name: DynamicPPL@0.31.5 (old syntax)
        shell: julia --color=yes --project=. {0}
        run: |
          using Pkg
          Pkg.add(name="DynamicPPL", version="0.31.5")

          using DynamicPPL
          using Chairmarks
          using Distributions
          using AbstractMCMC

          @model function _prior_dot_assume2(::Type{TV}=Vector{Float64}) where {TV}
              s = TV(undef, 2)
              s .~ InverseGamma(2, 3)
              m = TV(undef, 2)
              m .~ Normal.(0, sqrt.(s))
              return s, m
          end

          @model function demo_assume_submodel_observe_index_literal2()
              # Submodel prior
              @submodel s, m = _prior_dot_assume2()
              1.5 ~ Normal(m[1], sqrt(s[1]))
              2.0 ~ Normal(m[2], sqrt(s[2]))

              return (; s=s, m=m, x=[1.5, 2.0], logp=getlogp(__varinfo__))
          end

          t = @be sample(demo_assume_submodel_observe_index_literal2(), SampleFromUniform(), 100; progress=false)
          show(Base.stdout, MIME"text/plain"(), t)

      - name: DynamicPPL@0.31.5 (new syntax)
        shell: julia --color=yes --project=. {0}
        run: |
          using Pkg
          Pkg.add(name="DynamicPPL", version="0.31.5")

          using DynamicPPL
          using Chairmarks
          using Distributions
          using AbstractMCMC

          @model function _prior_dot_assume3(::Type{TV}=Vector{Float64}) where {TV}
              s = TV(undef, 2)
              s .~ InverseGamma(2, 3)
              m = TV(undef, 2)
              m .~ Normal.(0, sqrt.(s))
              return (; s=s, m=m)
          end

          @model function demo_assume_submodel_observe_index_literal3()
              # Submodel prior
              vars ~ to_submodel(_prior_dot_assume3())
              s = vars.s
              m = vars.m
              1.5 ~ Normal(m[1], sqrt(s[1]))
              2.0 ~ Normal(m[2], sqrt(s[2]))

              return (; s=s, m=m, x=[1.5, 2.0], logp=getlogp(__varinfo__))
          end

          t = @be sample(demo_assume_submodel_observe_index_literal3(), SampleFromUniform(), 100; progress=false)
          show(Base.stdout, MIME"text/plain"(), t)
