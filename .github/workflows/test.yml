on:
  push:
    branches:
      - "*"

jobs:
  test:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install Julia
        uses: julia-actions/setup-julia@v2
        with:
          version: '1'
          arch: x86

      - name: Cache
        uses: julia-actions/cache@v2

      - name: Instantiate
        run: julia --project=.github/workflows -e 'using Pkg; Pkg.instantiate()'

      - name: Test
        shell: julia --project=.github/workflows --color=yes --threads=2 {0}
        run: |
          using Turing, Test
          using LinearAlgebra

          @testset "vectorization @." begin
              @model function vdemo1(x)
                  s ~ InverseGamma(2, 3)
                  m ~ Normal(0, sqrt(s))
                  @. x ~ Normal(m, sqrt(s))
                  return s, m
              end

              alg = HMC(0.01, 5)
              x = randn(100)
              res = sample(vdemo1(x), alg, 250)

              @model function vdemo1b(x)
                  s ~ InverseGamma(2, 3)
                  m ~ Normal(0, sqrt(s))
                  @. x ~ Normal(m, $(sqrt(s)))
                  return s, m
              end

              res = sample(vdemo1b(x), alg, 250)

              @model function vdemo2(x)
                  μ ~ MvNormal(zeros(size(x, 1)), I)
                  @. x ~ $(MvNormal(μ, I))
              end

              D = 2
              alg = HMC(0.01, 5)
              res = sample(vdemo2(randn(D, 100)), alg, 250)

              # Vector assumptions
              N = 10
              alg = HMC(0.2, 4; adtype=AutoForwardDiff(; chunksize=N))

              @model function vdemo3()
                  x = Vector{Real}(undef, N)
                  for i in 1:N
                      x[i] ~ Normal(0, sqrt(4))
                  end
              end

              t_loop = @elapsed res = sample(vdemo3(), alg, 1000)

              # Test for vectorize UnivariateDistribution
              @model function vdemo4()
                  x = Vector{Real}(undef, N)
                  @. x ~ Normal(0, 2)
              end

              t_vec = @elapsed res = sample(vdemo4(), alg, 1000)

              @model vdemo5() = x ~ MvNormal(zeros(N), 4 * I)

              t_mv = @elapsed res = sample(vdemo5(), alg, 1000)

              println("Time for")
              println("  Loop : ", t_loop)
              println("  Vec  : ", t_vec)
              println("  Mv   : ", t_mv)

              # Transformed test
              @model function vdemo6()
                  x = Vector{Real}(undef, N)
                  @. x ~ InverseGamma(2, 3)
              end

              sample(vdemo6(), alg, 1000)

              N = 3
              @model function vdemo7()
                  x = Array{Real}(undef, N, N)
                  @. x ~ [InverseGamma(2, 3) for i in 1:N]
              end

              sample(vdemo7(), alg, 1000)
          end
          @testset "vectorization .~" begin
              @model function vdemo1(x)
                  s ~ InverseGamma(2, 3)
                  m ~ Normal(0, sqrt(s))
                  x .~ Normal(m, sqrt(s))
                  return s, m
              end

              alg = HMC(0.01, 5)
              x = randn(100)
              res = sample(vdemo1(x), alg, 250)

              @model function vdemo2(x)
                  μ ~ MvNormal(zeros(size(x, 1)), I)
                  return x .~ MvNormal(μ, I)
              end

              D = 2
              alg = HMC(0.01, 5)
              res = sample(vdemo2(randn(D, 100)), alg, 250)

              # Vector assumptions
              N = 10
              alg = HMC(0.2, 4; adtype=AutoForwardDiff(; chunksize=N))

              @model function vdemo3()
                  x = Vector{Real}(undef, N)
                  for i in 1:N
                      x[i] ~ Normal(0, sqrt(4))
                  end
              end

              t_loop = @elapsed res = sample(vdemo3(), alg, 1000)

              # Test for vectorize UnivariateDistribution
              @model function vdemo4()
                  x = Vector{Real}(undef, N)
                  return x .~ Normal(0, 2)
              end

              t_vec = @elapsed res = sample(vdemo4(), alg, 1000)

              @model vdemo5() = x ~ MvNormal(zeros(N), 4 * I)

              t_mv = @elapsed res = sample(vdemo5(), alg, 1000)

              println("Time for")
              println("  Loop : ", t_loop)
              println("  Vec  : ", t_vec)
              println("  Mv   : ", t_mv)

              # Transformed test
              @model function vdemo6()
                  x = Vector{Real}(undef, N)
                  return x .~ InverseGamma(2, 3)
              end

              sample(vdemo6(), alg, 1000)

              @model function vdemo7()
                  x = Array{Real}(undef, N, N)
                  return x .~ [InverseGamma(2, 3) for i in 1:N]
              end

              sample(vdemo7(), alg, 1000)
          end
          @testset "Type parameters" begin
              N = 10
              alg = HMC(0.01, 5; adtype=AutoForwardDiff(; chunksize=N))
              x = randn(1000)
              @model function vdemo1(::Type{T}=Float64) where {T}
                  x = Vector{T}(undef, N)
                  for i in 1:N
                      x[i] ~ Normal(0, sqrt(4))
                  end
              end

              t_loop = @elapsed res = sample(vdemo1(), alg, 250)
              t_loop = @elapsed res = sample(vdemo1(DynamicPPL.TypeWrap{Float64}()), alg, 250)

              vdemo1kw(; T) = vdemo1(T)
              t_loop = @elapsed res = sample(
                  vdemo1kw(; T=DynamicPPL.TypeWrap{Float64}()), alg, 250
              )

              @model function vdemo2(::Type{T}=Float64) where {T<:Real}
                  x = Vector{T}(undef, N)
                  @. x ~ Normal(0, 2)
              end

              t_vec = @elapsed res = sample(vdemo2(), alg, 250)
              t_vec = @elapsed res = sample(vdemo2(DynamicPPL.TypeWrap{Float64}()), alg, 250)

              vdemo2kw(; T) = vdemo2(T)
              t_vec = @elapsed res = sample(
                  vdemo2kw(; T=DynamicPPL.TypeWrap{Float64}()), alg, 250
              )

              @model function vdemo3(::Type{TV}=Vector{Float64}) where {TV<:AbstractVector}
                  x = TV(undef, N)
                  @. x ~ InverseGamma(2, 3)
              end

              sample(vdemo3(), alg, 250)
              sample(vdemo3(DynamicPPL.TypeWrap{Vector{Float64}}()), alg, 250)

              vdemo3kw(; T) = vdemo3(T)
              sample(vdemo3kw(; T=DynamicPPL.TypeWrap{Vector{Float64}}()), alg, 250)
          end
